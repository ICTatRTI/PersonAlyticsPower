#' \code{polyICT} class generator
#'
#' @docType class
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @export
#'
#'
#'
#' @field n Numeric (integer). The number of participants. Default is 10.
#'
#' @field phases List. Each phase in one item in the list with the phase name
#' repeated for the number of time points in the phase. For example, an "ABA"
#' study with 5 time points each would be \code{list(rep("A", 5), rep("B", 5),
#' rep("A", 5))}. See also the function \code{\link{makePhase}}. Default is
#' \code{makePhase()}.
#'
#' @field propErrVar Length 3 numeric vector. Default is \code{c(.5,.25,.25)}.#'
#' Proporotion of the total variance
#' that is due to [1] random effects, [2] residual autocorrelation, and
#' [3] measurement error. The values in \code{propErrVar} must sum to one.
#'
#' @field effectSizes A length 2 list with the names `randFx` and `fixdFx`. Each
#' are themselves a list with the coefficients for a polynomial growth model.
#' The length of `randFx` and `fixdFx` corresponds to the order of the model,
#' where an order of 2 would be a linear model and an order of 3 would be a
#' quadratic model. An example of a quadratic model would be
#' list(randFx = list(intercept = 0, slope = .5, quad = .2),
#'      fixdFx = list(phase = 1, phaseSlope = .2, phaseQuad = .1))
#'
#' @field corMat Numeric matrix. A symmetric correlation matrix with a dimension
#' equal to the order of the model. For example, a quadratic model would
#' correpspond to a 3x3 matrix. The diagonal elements must equal 1, the off
#' diagonal elements must be between -1 and +1, and the matrix must be
#' invertable.
#'
#' @field randFxVar Numeric vector. A vector of the same length as the order of
#' the polynomial
#' model containing the variances of the random effects. For example, in a
#' quadratic model, `randFxVar` would be length three, the first element would
#' be the intercept variance, the second element would be the slope variance,
#' and the third element would be the variance of the quadratic term.
#'
#' @field SigmaFun An R function. A function to convert \code{corMat} and
#' \code{randFxVar} into the covariance matrix \code{covMat}. Default is
#' \code{\link{cor2cov}}.
#'
#' @return
#'
#' \item{n               }{The number of participants (see `Fields`).}
#' \item{phases          }{The phases of the study (see `Fields`).}
#' \item{propErrVar      }{The proportion of error variance (see `Fields`).}
#' \item{effectSizes     }{The fixed effects effect sizes (see `Fields`).}
#' \item{corMat          }{The correlation matrix of the random effects (see `Fields`).}
#' \item{randFxVar       }{The variance of the random effects (see `Fields`).}
#' \item{muFUN           }{A function for transforming random effects means (see `Fields`).}
#' \item{SigmaFun        }{A function for constructing the covariance matrix (see `Fields`).}
#' \item{polyOrder       }{The order of the study. For example, a linear model
#' would be of order 1, and a quadratic model would be order 2.}
#' \item{designMat       }{The design matrix for one participant showing the structure
#' of study timing and phases.}
#' \item{covMat          }{The covariance matrix constructed using \code{corMat},
#' \code{randFxVar}, and \code{SigmaFun}.}
#' \item{nObservations   }{The number of observations per participant.}
#' \item{variances       }{Partition of the total variance into that due to
#' random effects and that due to error variance at time = 1.}
#' \item{expectedVariance}{The expected variances across all time points. This will
#' not match the variance of the simulated data unless n is large. See the \code{checkDesign}
#' parameter in \code{\link{ICTpower}}.}
#' \item{unStdEffects    }{The unstandardized effect sizes constructed from the total
#' \code{expectedVariance} and the \code{effectSizes}.}

#'
#' @examples
#'
#' # produce a simple ICT design
#' defaultPolyICT <- polyICT$new()
#'
#' # print a summary
#' defaultPolyICT
#'
#' # view the fields that are generated by `$new()` but cannot be changed by
#' # the user
#' defaultPolyICT$polyOrder
#' defaultPolyICT$designMat
#' defaultPolyICT$covMat
#' defaultPolyICT$nObservations
#' defaultPolyICT$variances
#' defaultPolyICT$expectedVariances
#' defaultPolyICT$unStdEffects

polyICT <- R6::R6Class("polyICT",

                       inherit = ICTdesign,

                       private = list(
                         .n                 = NULL,
                         .phases            = NULL,
                         .propErrVar        = NULL,
                         .effectSizes       = NULL,
                         .corMat            = NULL,
                         .randFxVar         = NULL,
                         .muFUN             = NULL,
                         .SigmaFun          = NULL,
                         .polyOrder         = NULL,
                         .designMat         = NULL,
                         .covMat            = NULL,
                         .nObservations     = NULL,
                         .variances         = NULL,
                         .expectedVariances = NULL,
                         .unStdEffects      = NULL
                       ),

                       public  = list(
                         initialize = function
                         (
                           n                 = 10                                        ,
                           phases            = makePhase()                               ,
                           propErrVar        = c(.5,.25,.25)                             ,
                           effectSizes       = list(phase1=list(group1=c(0,0),
                                                                group2=c(0,0)),
                                                    phase2=list(group1=c(0,0),
                                                                group2=c(.3,0)),
                                                    phase3=list(group1=c(0,0),
                                                                group2=c(.3,-.1)))       ,
                           corMat            = matrix(c(1,.2,.2,1), 2, 2)                ,
                           randFxVar         = c(1, .1)                                  ,
                           muFUN             = function(x) x                             ,
                           SigmaFun          = cor2cov                                   ,
                           polyOrder         = NULL                                      ,
                           designMat         = NULL                                      ,
                           covMat            = NULL                                      ,
                           nObservations     = NULL                                      ,
                           variances         = NULL                                      ,
                           expectedVariances = NULL                                      ,
                           unStdEffects      = NULL
                         )
                         {
                           # general input validation
                           # TODO replace polyOrder which used to live here
                           polyInputs <- checkPolyICT(effectSizes, phases,
                                                      corMat, randFxVar)
                           cormat           <- polyInputs$corMat
                           covmat           <- polyInputs$covMat
                           randFxVar        <- polyInputs$randFxVar
                           phaseNames       <- polyInputs$phaseNames
                           groupNames       <- polyInputs$groupNames
                           maxRandFx        <- polyInputs$maxRandFx
                           unStdEffectSizes <- polyInputs$unStdEffectSizes
                           rm(polyInputs)

                           # construct the fixed effects design matrix, only one
                           # is needed across all combinations of group and phase
                           # by using maxRandFx, any unneeded columns will be
                           # ignored when constructing data
                           designMat <- getICTdesign(phases, maxRandFx, 'polyICT')

                           # get the number of observations
                           nObservations <- length(c(unlist(phases)))

                           # RESUME HERE: this needs to be moved to the make data
                           # loops b/c it is phase/group specific; or, move it
                           # to checkPolyICT; also propErrVar should be allowed to be
                           # phase and group specific
                           # get the total variance and the error variance @ time = 1
                           totalVar  <- sum(covMat)/(1-propErrVar)
                           errorVar  <- propErrVar * totalVar
                           variances <- list(totalVar = totalVar,
                                             errorVar = errorVar,
                                             randFxVar = totalVar - errorVar)

                           # get the expected varariances
                           # initial values
                           expectedVariances <- expectedVar(covMat, designMat, variances,
                                                            effectSizes, nObservations, n)
                           unStdEffects      <- expectedVariances$effectSizes

                           # populate private
                           private$.n                 <- n
                           private$.phases            <- phases
                           private$.propErrVar        <- propErrVar
                           private$.effectSizes       <- effectSizes
                           private$.corMat            <- corMat
                           private$.randFxVar         <- randFxVar
                           private$.muFUN             <- muFUN
                           private$.SigmaFun          <- SigmaFun
                           private$.polyOrder         <- polyOrder
                           private$.designMat         <- designMat
                           private$.covMat            <- covMat
                           private$.nObservations     <- nObservations
                           private$.variances         <- variances
                           private$.expectedVariances <- expectedVariances
                           private$.unStdEffects      <- unStdEffects

                         },

                         print = function(...)
                         {
                           # use super to call the print function of the parent class
                           super$print()


                           # add print options for the child class
                           cat("\n\nEffect sizes:\n",
                               paste(unlist(lapply(self$effectSizes, names)), '=',
                                     unlist(self$effectSizes), '\n'),
                               "\nRandom Effects\n",
                               "\nCorrelation matrix:\n", catMat(self$corMat),
                               "\nCovariance matrix:\n",  catMat(round(self$covMat,3))
                           )

                         },

                         makeData = function(randFx, errors, ymean=NULL, yvar=NULL)
                         {

                           for(p in seq_along(self$phases))
                           {

                           }
                         }

                       )
)


# TODO:need to generalize beyond slopes
#' expectedVar
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @keywords internal
#'
expectedVar <- function(covMat, designMat, variances,
                        effectSizes, nObservations, n)
{
  # 'total' N
  N <- nObservations * n

  # variance at each time point
  vyt <-  covMat[1,1]            +
    designMat$Time^2*covMat[2,2] +
    2*covMat[1,2]                +
    variances$errorVar

  # total variance due to random effects and error variance
  sigmaT <- (N-1)^-1 * ( (n - 1) * sum(vyt) )

  # rescale the fixed effect sizes in terms of the variance when time = 1
  whereIsTeq1 <- which(designMat$Time==1)
  sdYt1 <- sqrt( vyt[whereIsTeq1] )
  effectSizes$fixdFx$phase     <- effectSizes$fixdFx$phase     * sdYt1
  effectSizes$fixdFx$phaseTime <- effectSizes$fixdFx$phaseTime * sdYt1

  # mean at each time point
  mt <-  (effectSizes$randFx$intercept                       +
            effectSizes$randFx$slope     * designMat$Time      +
            effectSizes$fixdFx$phase     * designMat$phase     +
            effectSizes$fixdFx$phaseTime * designMat$phaseTime
  )

  # overall mean
  m = mean(mt)

  # total variance due to fixed effects stacked over time
  muT <- (N-1)^-1 * ( n * sum((mt-m)^2) )

  # overall variance
  vy     <- sigmaT + muT
  #  (N-1)^-1 * ( n * sum((mt-m)^2) + (n - 1) * sum(vyt) )


  return( list(effectSizes = effectSizes ,
               Variances   = vyt         ,
               Means       =  mt         ,
               TotalMean   =   m         ,
               TotalVar    =  vy         ) )
}

#' checkPolyICT
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @keywords internal
#'
# TODO: if anything in this function is useful for polyICT2, export to functions
# or make it part of ICTdesign to pass by inheritance
checkPolyICT <- function(effectSizes, phases, corMat, randFxVar)
{
  # check conformity of the elements in `effectSizes`
  effectSizes <<- effectSizes
  effectSizeLengths <- lapply(effectSizes, length)
  if(!all(unlist(effectSizeLengths)==effectSizeLengths[[1]]))
  {
    stop('There are unequal numbers of groups within each phase in `effectSizes`.\n',
         paste(names(effectSizeLengths), 'has', unlist(effectSizeLengths), 'groups.\n'))
  }
  groupNames <- lapply(effectSizes, names)
  groupNamesEqual <- outer(groupNames, groupNames, Vectorize(all.equal))
  if(!all(groupNamesEqual))
  {
    stop('The group names in `effectSizes` are not the same for all phases.\n',
         paste(names(effectSizes), ':', groupNames, '.\n'))
  }
  groupNames <- groupNames[[1]]
  if(length(effectSizes) != length(phases))
  {
    stop('`effectSizess` is length ', length(effectSizes),
         ' while `phases` is length ', length(phase), '.\n',
         'The two should be equal length, i.e., `effectSizess` has one\n',
         'set of parameters for each phase in `phases`.')
  }
  phaseNames <- names(phases)
  if(!all(names(effectSizes)==phaseNames))
  {
    stop('The phase names in `effectSizes` are not the same as the \n',
         'phase names in `phases`.\n',
         paste(names(effectSizes), 'vs.', names(phases), '.\n'))
  }

  # check conformity of correlation matrices, must be per phase, per group
  if(is.list(corMat))
  {
    corMatLengths <- lapply(corMat, length)
    # if corMat only given for phases, assume equal across groups
    if(all(names(corMat) %in% phaseNames) & !any(corMatLengths > 1))
    {
      corMatL <- corMatPop(phaseNames, groupNames, corMat, 'p')
    }
    # if corMat only given for groups, assume equal across phases
    if(all(names(corMat) %in% groupNames) & !any(corMatLengths > 1))
    {
      corMatL <- corMatPop(phaseNames, groupNames, corMat, 'g')
    }
    # if corMat given for both phases and groups, check dimension conformity
    if(all(names(corMat) %in% phaseNames) & all(corMatLengths > 1))
    {
      if(! all.equal(unlist(corMatLengths), unlist(effectSizeLengths)) )
      {
        stop('The list of correlation matrices in `corMat` do not have the same\n',
             'number of groups and/or phases as in `effectSizes`. You can specify\n',
             'a list with just one correlation matrix per phase which will be\n',
             'applied to each group. Or you can specify one correlation matrix per\n',
             'group which will be applied to each phase. See the examples in ?polyICT.')
      }
    }
  }

  # if only one corMat is given, repeat it for all phases and groups
  if(!is.list(corMat))
  {
    corMatL <- corMatPop(phaseNames, groupNames, corMat, 'n')
  }

  # check conformity of random effects variances, must be per phase, per group
  if(is.list(randFxVar))
  {
    randFxVarLengths <- lapply(randFxVar, length)
    # if randFxVar only given for phases, assume equal across groups
    if(all(names(randFxVar) %in% phaseNames) & !any(randFxVarLengths > 1))
    {
      randFxVarL <- randFxVarPop(phaseNames, groupNames, randFxVar, 'p')
    }
    # if randFxVar only given for groups, assume equal across phases
    if(all(names(randFxVar) %in% groupNames) & !any(randFxVarLengths > 1))
    {
      randFxVarL <- randFxVarPop(phaseNames, groupNames, randFxVar, 'g')
    }
    # if randFxVar given for both phases and groups, check dimension conformity
    if(all(names(randFxVar) %in% phaseNames) & all(randFxVarLengths > 1))
    {
      if(! all.equal(unlist(randFxVarLengths), unlist(effectSizeLengths)) )
      {
        stop('The list of correlation matrices in `randFxVar` do not have the same\n',
             'number of groups and/or phases as in `effectSizes`. You can specify\n',
             'a list with just one correlation matrix per phase which will be\n',
             'applied to each group. Or you can specify one correlation matrix per\n',
             'group which will be applied to each phase. See the examples in ?polyICT.')
      }
    }
  }

  # if only one randFxVar is given, repeat it for all phases and groups
  if(!is.list(randFxVar))
  {
    randFxVarL <- randFxVarPop(phaseNames, groupNames, randFxVar, 'n')
  }

  # update corMat and randFxVar
  # TODO add error if for some reason corMatL or randFxVarL don't exist
  corMat <- corMatL
  randFxVar <- randFxVarL

  # check conformity of `corMat` with `effectSizes`, get covMat, and
  # get unstandardized effect sizes
  covMatL <- list()
  unStdEffectSizesL <- list()
  for(p in seq_along(phaseNames))
  {
    for(g in seq_along(groupNames))
    {
      # check by name instead of index for situations where the user doesn't
      # index consistently but still has consistent names
      tP <- phaseNames[p]
      tG <- groupNames[g]
      # are the random effect means in effectSizes the same dimension as
      # the corresponding corMat?
      if( length(effectSizes[[tP]][[tG]]) != dim(corMat[[tP]][[tG]])[1] )
      {
        stop('There are ', length(effectSizes[[tP]][[tG]]), ' random effect means\n',
             'for ', tP, ' and ', tG, ' in `effectSizes`, but the corresponding\n',
             'correlation matrix in `corMat` has dimension ', dim(corMat[[tP]][[tG]])[1],
             '.')
      }
      # are the dimensions of corMat consitent with the number of variances
      # in
      if( dim(corMat[[tP]][[tG]])[1] != length(randFxVar[[tP]][[tG]]) )
      {
        stop('The correlation matrix in `corMat` has dimension ',
             dim(corMat[[tP]][[tG]])[1], ' for ', tP, ' and ', tG,
             '\n but there are ', length(randFxVar[[tP]][[tG]]),
             ' correpsonding variances in `randFxVar`.')
      }

      # check that `corMat` is a correlation matrix
      checkCorMat(corMat[[tP]][[tG]])

      # check that resulting covariance matrix is legit
      covMatL[[tP]][[tG]] <- SigmaFun(corMat[[tP]][[tG]], randFxVar[[tP]][[tG]])
      checkCorMat(covMatL[[tP]][[tG]], FALSE)

      # get unstandardized effects
      randFxSD <- sqrt(diag(covMatL[[tP]][[tG]]))
      unStdEffectSizesL[[tP]][[tG]] <- effectSizes[[tP]][[tG]]*randFxSD

    }
  }

  # get the maximum number of random effects
  maxRandFx <- max( unlist( effectSizeLengths) )


  return( list(phaseNames       = phaseNames        ,
               groupNames       = groupNames        ,
               corMat           = corMat            ,
               covMat           = covMatL           ,
               randFxVar        = randFxVar         ,
               maxRandFx        = maxRandFx         ,
               unStdEffectSizes = unStdEffectSizesL ) )
}

#' checkEffectSizes
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @keywords internal
#'
checkEffectSizesPoly <- function(effectSizes)
{
  # check conformity of the elements in `effectSizes`
  FxNames <- c( "randFx", "fixdFx")
  test1   <- all( names(effectSizes) %in% FxNames)
  if(!test1) stop('`effectSizes` must be a length 2 list with the names ',
                  paste('`', FxNames, '`', collapse=', ', sep=''))
  nFx   <- lapply(effectSizes, length)
  test2 <- nFx[[1]]==nFx[[2]]
  if(!test2) stop('`effectSizes$randFx` must have the same number of elements\n',
                  'as `effectSizes$fixdFx`.')
  invisible(nFx)
}


