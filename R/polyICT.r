#' \code{polyICT} class generator
#'
#' @docType class
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @export
#'
#' @usage polyICT$new()
#'
#' @field n Numeric (integer). The number of participants. Default is 10.
#'
#' @field phases List. Each phase in one item in the list with the phase name
#' repeated for the number of time points in the phase. For example, an "ABA"
#' study with 5 time points each would be \code{list(rep("A", 5), rep("B", 5),
#' rep("A", 5))}. See also the function \code{\link{makePhase}}. Default is
#' \code{makePhase()}.
#'
#' @field propErrVar Length 3 numeric vector. Default is \code{c(.5,.25,.25)}.#'
#' Proporotion of the total variance
#' that is due to [1] random effects, [2] residual autocorrelation, and
#' [3] measurement error. The values in \code{propErrVar} must sum to one.
#'
#' @field randFxMean A length 2 list with the names `randFx` and `fixdFx`. Each
#' are themselves a list with the coefficients for a polynomial growth model.
#' The length of `randFx` and `fixdFx` corresponds to the order of the model,
#' where an order of 2 would be a linear model and an order of 3 would be a
#' quadratic model. An example of a quadratic model would be
#' list(randFx = list(intercept = 0, slope = .5, quad = .2),
#'      fixdFx = list(phase = 1, phaseSlope = .2, phaseQuad = .1))
#'
#' @field randFxCorMat Numeric matrix. A symmetric correlation matrix with a dimension
#' equal to the order of the model. For example, a quadratic model would
#' correpspond to a 3x3 matrix. The diagonal elements must equal 1, the off
#' diagonal elements must be between -1 and +1, and the matrix must be
#' invertable.
#'
#' @field randFxVar Numeric vector. A vector of the same length as the order of
#' the polynomial
#' model containing the variances of the random effects. For example, in a
#' quadratic model, `randFxVar` would be length three, the first element would
#' be the intercept variance, the second element would be the slope variance,
#' and the third element would be the variance of the quadratic term.
#'
#' @return
#'
#' \item{n               }{The number of participants (see `Fields`).}
#' \item{phases          }{The phases of the study (see `Fields`).}
#' \item{phaseNames      }{The names of the phases.}
#' \item{groupNames      }{The names of the groups.}
#' \item{propErrVar      }{The proportion of error variance (see `Fields`).}
#' \item{randFxMean     }{The fixed effects effect sizes (see `Fields`).}
#' \item{randFxCorMat          }{The correlation matrix of the random effects (see `Fields`).}
#' \item{randFxVar       }{The variance of the random effects (see `Fields`).}
#' \item{maxRandFx       }{The highest order for polynomial random effects.}
#' \item{designMat       }{The design matrix for one participant showing the structure
#' of study timing and phases.}
#' \item{randFxCovMat          }{The covariance matrix constructed using \code{randFxCorMat},
#' and \code{randFxVar}.}
#' \item{nObs   }{The number of observations per participant.}
#' \item{variances       }{Partition of the total variance into that due to
#' random effects and that due to error variance at time = 1.}
#' \item{expectedVariance}{The expected variances across all time points. This will
#' not match the variance of the simulated data unless n is large. See the \code{checkDesign}
#' parameter in \code{\link{ICTpower}}.}
#' \item{unStdRandFxMean    }{The unstandardized effect sizes constructed from the total
#' \code{expectedVariance} and the \code{randFxMean}.}
#'
#' @examples
#'
#' # produce a simple ICT design, the defaults have a group 1 with
#' # no change over time and a group 2 with a d=.3 phase jump between phase 1
#' # and phase 2, then d=-1 linear decrease in phase 3
#' t1 <- polyICT$new()
#'
#' # three ways to print a summary
#' t1$print()
#' t1
#' print(t1)
#'
#' # view the fields that are generated by `$new()` from user inputs, but
#' # cannot be changed by the user
#' t1$nObs
#' t1$designMat
#' t1$phaseNames
#' t1$groupNames
#' t1$designMat
#' t1$unStdRandFxMean#'
#' t1$randFxCovMat
#'
#'
#' # TODO - fix these
#' #t1$variances
#' #t1$expectedVariances
#'
#' # do a design check
#' t1pa <- t1$designCheck(ylim = c(50,150))
#' # print the density instead of histogram (type can be passed to designCheck)
#' t1pa$plot(type='density') # TODO not working, debug
#'
#' t1$designCheck()
#' t1$designCheck(npg=20)
#'
#' # change parameters
#' t1$n <- 20
#' t1$n
#'
#' t1$phases <- makePhase(nObsPerPhase = c(5,20,20),
#'                        phaseNames = paste('phase', 1:3, sep=''))
#' t1$phases
#'
#' t1$propErrVar = c(.4,.3,.3)
#' t1$propErrVar
#'
#' t1$randFxMean <- list(phase1=list(group1=c(0,0),
#'                                   group2=c(0,0)),
#'                       phase2=list(group1=c(-1,0),
#'                                   group2=c(.3,0)),
#'                       phase3=list(group1=c(1,0),
#'                                   group2=c(.3,-1)))
#' t1$randFxMean
#'
#' t1$randFxVar <- c(1,2)
#' t1$randFxVar
#'
#' t1$randFxCorMat <- matrix(c(1,0,0,1), 2, 2)
#'
#' t1$randFxCorMat
#' t1$randFxCovMat
#'
#' TODO: move to don't run
#'
#' # quadratic model - curvelinear down in phase 2, linear up in phase 3
#' t2 <- polyICT$new(n=100, phases=makePhase(),
#'                   randFxMean = list(phase1=list(group1=c(0,0,0)),
#'                        phase2=list(group1=c(0,.1,-.5)),
#'                        phase3=list(group1=c(-.5,.5,0))),
#'                   randFxCorMat = matrix(c(1,.2,.2,.2,1,.2,.2,.2,1),3,3),
#'                   randFxVar=c(1,1,1))
#' t2pa <- t2$designCheck()
#'

# TODO no more todos

# TODO how many of the items in private can be moved to designICT because all
# heirs should have them?
# TODO document initialize
polyICT <- R6::R6Class("polyICT",

                       inherit = designICT,

                       public  = list(
                         initialize = function
                         (
                           groups            = c(group1=10, group2=10)                   ,
                           phases            = makePhase()                               ,
                           propErrVar        = c(randFx=.5,res=.25,mserr=.25)            ,
                           randFxOrder       = 0:1                                       ,
                           randFxCor         = 0.2                                       ,
                           randFxVar         = c(1, 1)                                   ,

                           error             = armaErr$new()                             ,
                           merror            = armaErr$new(list())                       ,
                           ySD               = 15                                        ,
                           yMean             = 100                                       ,

                           # these should be hidden from users until we can model
                           # non-normal random effects
                           randFxFam         = "qNO"                                     ,
                           randFxFamParms    = list(mu=.5 , sigma=1)

                         )
                         {
                           # makeDesign
                           design <- makeDesign(randFxOrder, phases, groups,
                                                propErrVar, randFxVar,
                                                randFxCor, design = 'polyICT')


                           #
                           # populate private
                           #
                           #private$.edit              <- TRUE

                           # editable without a new call to $new
                           private$.inputMat          <- design$inputMat
                           private$.randFxVar         <- design$randFxVar
                           private$.randFxCorMat      <- design$randFxCorMat
                           private$.randFxCovMat      <- design$randFxCovMat
                           private$.propErrVar        <- design$propErrVar
                           private$.error             <- error
                           private$.merror            <- merror
                           private$.yMean             <- yMean
                           private$.ySD               <- ySD

                           # not editable
                           private$.n                 <- design$n
                           private$.nObs              <- design$nObs
                           private$.groups            <- design$groups
                           private$.phases            <- design$phases
                           private$.designMat         <- design$designMat
                           private$.unStdRandFxMean   <- design$unStdRandFxMean
                           private$.meanNames         <- design$meanNames
                           private$.varNames          <- design$varNames
                           private$.phaseNames        <- names(phases)
                           private$.groupNames        <- names(groups)
                           private$.randFxOrder       <- randFxOrder

                           # not implemented
                           private$.randFxFam         <- randFxFam
                           private$.randFxFamParms    <- randFxFamParms

                           # variances TODO repopulate these after moving their function to ??
                           #private$.variances         <- variances
                           #private$.expectedVariances <- expectedVariances
                           # internals
                           #private$.edit              <- FALSE


                         },

                         print = function(...)
                         {
                           # use super to call the print function of the parent
                           # class, then you can add anything specific to this
                           # class
                           super$print()
                           invisible(self)
                         },

                         # update function to repeate QC steps in $new (which
                         # calls $initialize) rather than repeating this code
                         # in each active binding
                         update = function(...)
                         {
                           # Turn off warnings so that active binding messages,
                           # which should be implemented as warnings, are
                           # turned off (checkPolyICT will handle via errors)
                           options(warn=-1)
                           #self$edit <- TRUE

                           # This will call each active binding in self for
                           # passed parameters, hence warn=-1
                           dots <-  list(...)#match.call(expand.dots = FALSE)$...
                           #print(dots)
                           dotsNames <- names(dots)
                           for(i in seq_along(dots))
                           {
                             if( dotsNames[i] %in% names(self) )
                             {
                               self[[dotsNames[i]]] <- dots[[i]]
                             }
                             if( ! dotsNames[i] %in% names(self) )
                             {
                               message("The parameter `", dotsNames[i], "` is not ",
                                    "a valid parameter for a `polyICT`\n",
                                    "object and will be ignored.")
                             }
                           }
                           # only run this if
                           if(names(dots) %in% c('groups', 'randFxMean', 'phases',
                                                 'randFxCorMat', 'randFxVar'))
                           {
                             design <- makeDesign(randFxOrder, phases, groups,
                                                  propErrVar, randFxVar,
                                                  randFxCor, design = 'polyICT')

                             self$inputMat          <- design$inputMat
                             self$randFxVar         <- design$randFxVar
                             self$randFxCorMat      <- design$randFxCorMat
                             self$randFxCovMat      <- design$randFxCovMat
                             self$propErrVar        <- design$propErrVar
                             self$n                 <- design$n
                             self$nObs              <- design$nObs
                             self$groups            <- design$groups
                             self$phases            <- design$phases
                             self$designMat         <- design$designMat
                             self$unStdRandFxMean   <- design$unStdRandFxMean
                             self$meanNames     <- design$meanNames
                             self$varNames      <- design$varNames
                             rm(design)

                             if(!all(names(self$phases)==self$phaseNames))
                             {
                               names(self$phases) <- self$phaseNames
                             }

                             self$designMat <- makeDesignMat(self$phases,
                                                             self$phaseNames,
                                                             self$maxRandFx,
                                                             'polyICT')

                             self$nObs <- length(c(unlist(self$phases)))
                           }

                           # reset warnings
                           options(warn=0)
                           #self$edit <- FALSE

                           # return self to allow for chaining of method calls
                           invisible(self)
                         },

                         # TODO we don't want to make the user pass multiple
                         # randFx and errors, so we pass the parameters
                         makeData = function(seed=123, yMean=100, ySD=15)
                         {
                           seeds <- .makeSeeds(seed, length(self$phaseNames) *
                                                length(self$groupNames))
                           seeds <- matrix(seeds, length(self$phaseNames),
                                           length(self$groupNames))
                           data <- list(); d <- 1
                           for(p in seq_along(self$phaseNames))
                           {
                             thisp <- self$phaseNames[[p]]
                             for(g in seq_along(self$groupNames))
                             {
                               thisg <- self$groupNames[[g]]
                               # Sigma should be CorMat, not CovMat, otherwhise
                               # the slope variance (and higher polynomial terms)
                               # get scaled twice
                               Sigma <- self$randFxCorMat[[thisp]][[thisg]]
                               mu    <- self$unStdRandFxMean[
                                 self$unStdRandFxMean$Phase==thisp &
                                   self$unStdRandFxMean$Group==thisg,
                                 self$meanNames]
                               n     <- self$groups[[thisg]]
                               nObs  <- length(self$phases[[thisp]])
                               dM    <- self$designMat[self$designMat$phase==thisp,]
                               rFxVr <- self$unStdRandFxMean[
                                 self$unStdRandFxMean$Phase==thisp &
                                   self$unStdRandFxMean$Group==thisg,
                                 self$varNames]
                               propErrVar <- self$unStdRandFxMean[
                                 self$unStdRandFxMean$Phase==thisp &
                                   self$unStdRandFxMean$Group==thisg,
                                 c('randFx', 'res', 'mserr')]

                               # calls to polyData() here
                               data[[d]] <- polyData(seed       = seeds[p,g]         ,
                                                     n          = n                  ,
                                                     nObs       = nObs               ,
                                                     mu         = unlist(mu)         ,
                                                     Sigma      = Sigma              ,
                                                     self       = self               ,
                                                     dM         = dM                 ,
                                                     rFxVr      = unlist(rFxVr)      ,
                                                     propErrVar = unlist(propErrVar) ,
                                                     group      = thisg              )
                               d <- d + 1
                             }
                           }
                           data <- do.call(rbind, data)

                           # rescale the y variance if !is.null
                           if(is.null(yMean)) yMean <- mean(data$y)
                           if(is.null(ySD))     ySD <- sd(data$y)
                           # rescaling is done regardless of yMean and ySD just
                           # in case only one is non-null
                           data$y <- scale(data$y)*ySD + yMean

                           # the makeData method is terminal, self is not returned
                           # which means chaining is not possible past this point
                           return(data)

                         }

                       )
)


# TODO:need to generalize beyond slopes
#' expectedVar
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @keywords internal
#'
expectedVar <- function(randFxCovMat, designMat, variances,
                        randFxMean, nObs, n)
{
  # 'total' N
  N <- nObs * n

  # variance at each time point
  vyt <-  randFxCovMat[1,1]            +
    designMat$Time^2*randFxCovMat[2,2] +
    2*randFxCovMat[1,2]                +
    variances$errorVar

  # total variance due to random effects and error variance
  sigmaT <- (N-1)^-1 * ( (n - 1) * sum(vyt) )

  # rescale the fixed effect sizes in terms of the variance when time = 1
  whereIsTeq1 <- which(designMat$Time==1)
  sdYt1 <- sqrt( vyt[whereIsTeq1] )
  randFxMean$fixdFx$phase     <- randFxMean$fixdFx$phase     * sdYt1
  randFxMean$fixdFx$phaseTime <- randFxMean$fixdFx$phaseTime * sdYt1

  # mean at each time point
  mt <-  (randFxMean$randFx$intercept                         +
            randFxMean$randFx$slope     * designMat$Time      +
            randFxMean$fixdFx$phase     * designMat$phase     +
            randFxMean$fixdFx$phaseTime * designMat$phaseTime
  )

  # overall mean
  m = mean(mt)

  # total variance due to fixed effects stacked over time
  muT <- (N-1)^-1 * ( n * sum((mt-m)^2) )

  # overall variance
  vy     <- sigmaT + muT
  #  (N-1)^-1 * ( n * sum((mt-m)^2) + (n - 1) * sum(vyt) )


  return( list(randFxMean = randFxMean ,
               Variances   = vyt         ,
               Means       =  mt         ,
               TotalMean   =   m         ,
               TotalVar    =  vy         ) )
}

#' checkRandFxMean
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @keywords internal
#'
checkRandFxMeanPoly <- function(randFxMean)
{
  if(! var( unlist( lapply(randFxMean, length) ) ) == 0)
  {
    stop('All phases must have the same number of groups.')
  }

  if(! var(unlist( lapply(randFxMean, function(x) lapply(x, length)) ) ) == 0 )
  {
    stop('All combinations of phase and group must have the same number of\n',
         'random effects.')
  }
}






