#' \code{polyICT} class generator
#'
#' @docType class
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @export
#'
#' @usage polyICT$new()
#'
#' @field n Numeric (integer). The number of participants. Default is 10.
#'
#' @field phases List. Each phase in one item in the list with the phase name
#' repeated for the number of time points in the phase. For example, an "ABA"
#' study with 5 time points each would be \code{list(rep("A", 5), rep("B", 5),
#' rep("A", 5))}. See also the function \code{\link{makePhase}}. Default is
#' \code{makePhase()}.
#'
#' @field propErrVar Length 3 numeric vector. Default is \code{c(.5,.25,.25)}.#'
#' Proporotion of the total variance
#' that is due to [1] random effects, [2] residual autocorrelation, and
#' [3] measurement error. The values in \code{propErrVar} must sum to one.
#'
#' @field randFxMean A length 2 list with the names `randFx` and `fixdFx`. Each
#' are themselves a list with the coefficients for a polynomial growth model.
#' The length of `randFx` and `fixdFx` corresponds to the order of the model,
#' where an order of 2 would be a linear model and an order of 3 would be a
#' quadratic model. An example of a quadratic model would be
#' list(randFx = list(intercept = 0, slope = .5, quad = .2),
#'      fixdFx = list(phase = 1, phaseSlope = .2, phaseQuad = .1))
#'
#' @field randFxCorMat Numeric matrix. A symmetric correlation matrix with a dimension
#' equal to the order of the model. For example, a quadratic model would
#' correpspond to a 3x3 matrix. The diagonal elements must equal 1, the off
#' diagonal elements must be between -1 and +1, and the matrix must be
#' invertable.
#'
#' @field randFxVar Numeric vector. A vector of the same length as the order of
#' the polynomial
#' model containing the variances of the random effects. For example, in a
#' quadratic model, `randFxVar` would be length three, the first element would
#' be the intercept variance, the second element would be the slope variance,
#' and the third element would be the variance of the quadratic term.
#'
#' @return
#'
#' \item{n               }{The number of participants (see `Fields`).}
#' \item{phases          }{The phases of the study (see `Fields`).}
#' \item{phaseNames      }{The names of the phases.}
#' \item{groupNames      }{The names of the groups.}
#' \item{propErrVar      }{The proportion of error variance (see `Fields`).}
#' \item{randFxMean     }{The fixed effects effect sizes (see `Fields`).}
#' \item{randFxCorMat          }{The correlation matrix of the random effects (see `Fields`).}
#' \item{randFxVar       }{The variance of the random effects (see `Fields`).}
#' \item{maxRandFx       }{The highest order for polynomial random effects.}
#' \item{designMat       }{The design matrix for one participant showing the structure
#' of study timing and phases.}
#' \item{randFxCovMat          }{The covariance matrix constructed using \code{randFxCorMat},
#' and \code{randFxVar}.}
#' \item{nObs   }{The number of observations per participant.}
#' \item{variances       }{Partition of the total variance into that due to
#' random effects and that due to error variance at time = 1.}
#' \item{expectedVariance}{The expected variances across all time points. This will
#' not match the variance of the simulated data unless n is large. See the \code{checkDesign}
#' parameter in \code{\link{ICTpower}}.}
#' \item{unStdRandFxMean    }{The unstandardized effect sizes constructed from the total
#' \code{expectedVariance} and the \code{randFxMean}.}
#'
#' @examples
#'
#' # produce a simple ICT design, the defaults have a group 1 with
#' # no change over time and a group 2 with a d=.3 phase jump between phase 1
#' # and phase 2, then d=-1 linear decrease in phase 3
#' t1 <- polyICT$new()
#'
#' # three ways to print a summary
#' t1$print()
#' t1
#' print(t1)
#'
#' # view the fields that are generated by `$new()` from user inputs, but
#' # cannot be changed by the user
#' t1$nObs
#' t1$designMat
#' t1$phaseNames
#' t1$groupNames
#' t1$designMat
#' t1$unStdRandFxMean#'
#' t1$randFxCovMat
#'
#'
#' # TODO - fix these
#' #t1$variances
#' #t1$expectedVariances
#'
#' # do a design check
#' t1pa <- t1$designCheck(ylim = c(50,150))
#' # print the density instead of histogram (type can be passed to designCheck)
#' t1pa$plot(type='density') # TODO not working, debug
#'
#' # change parameters
#' t1$n <- 20
#' t1$n
#'
#' t1$phases <- makePhase(nObsPerPhase = c(5,20,20),
#'                        phaseNames = paste('phase', 1:3, sep=''))
#' t1$phases
#'
#' t1$propErrVar = c(.4,.3,.3)
#' t1$propErrVar
#'
#' t1$randFxMean <- list(phase1=list(group1=c(0,0),
#'                                   group2=c(0,0)),
#'                       phase2=list(group1=c(-1,0),
#'                                   group2=c(.3,0)),
#'                       phase3=list(group1=c(1,0),
#'                                   group2=c(.3,-1)))
#' t1$randFxMean
#'
#' t1$randFxVar <- c(1,2)
#' t1$randFxVar
#'
#' t1$randFxCorMat <- matrix(c(1,0,0,1), 2, 2)
#'
#' t1$randFxCorMat
#' t1$randFxCovMat
#'
#' TODO: move to don't run
#'
#' # quadratic model - curvelinear down in phase 2, linear up in phase 3
#' t2 <- polyICT$new(n=100, phases=makePhase(),
#'                   randFxMean = list(phase1=list(group1=c(0,0,0)),
#'                        phase2=list(group1=c(0,.1,-.5)),
#'                        phase3=list(group1=c(-.5,.5,0))),
#'                   randFxCorMat = matrix(c(1,.2,.2,.2,1,.2,.2,.2,1),3,3),
#'                   randFxVar=c(1,1,1))
#' t2pa <- t2$designCheck()
#'

# TODO no more todos

# TODO how many of the items in private can be moved to designICT because all
# heirs should have them?
# TODO document initialize
polyICT <- R6::R6Class("polyICT",

                       inherit = designICT,

                       public  = list(
                         initialize = function
                         (
                           groups            = c(group1=10, group2=10)                   ,
                           phases            = makePhase()                               ,
                           propErrVar        = c(randFx=.5,res=.25,mserr=.25)            ,
                           randFxOrder       = 0:1                                       ,
                           randFxCor         = 0.2                                       ,
                           randFxVar         = c(1, 1)                                   ,

                           error             = armaErr$new()                             ,
                           merror            = armaErr$new(list())                       ,
                           ySD               = 15                                        ,
                           yMean             = 100

                           # these should be hidden from users until we can model
                           # non-normal random effects
                           randFxFam         = "qNO"                                     ,
                           randFxFamParms    = list(mu=.5 , sigma=1)                     ,

                         )
                         {
                           # input check
                           if(length(randFxOrder) != length(randFxVar))
                           {
                             stop('`randFxOrder` and `randFxVar` must be the ',
                                  'same length.')
                           }

                           # expand groups and phases into a input matrix
                           inputMat <- cbind(
                             expand.grid(names(phases), names(groups)),
                             expand.grid(lapply(phases, length), groups))
                           names(inputMat) <- c('Phase', 'Group', 'nObs', 'n')
                           for(i in seq_along(randFxOrder))
                           {
                             inputMat[[paste('Mean', randFxOrder[i], sep='')]] <- 0
                           }
                           for(i in seq_along(randFxOrder))
                           {
                             inputMat[[paste('Var' , randFxOrder[i], sep='')]] <- randFxVar[i]
                           }
                           for(i in seq_along(propErrVar))
                           {
                             inputMat[[names(propErrVar)[i]]] <- propErrVar[i]
                           }
                           rm(i)
                           meanNames <- names(inputMat)[grepl('Mean', names(inputMat))]
                           varNames  <- names(inputMat)[grepl('Var', names(inputMat))]

                           # construct randFx correlation matrices that can be
                           # edited later
                           randFxCorMat <- randFxCovMat <- list()
                           CorMat <- matrix(randFxCor,
                                            length(randFxOrder),
                                            length(randFxOrder))
                           diag(CorMat) <- 1
                           for(p in seq_along(phases))
                           {
                             .np <- names(phases)[p]
                             for(g in seq_along(groups))
                             {
                               .ng <- names(groups)[g]
                               randFxCorMat[[.np]][[.ng]] <- CorMat
                               .V <- inputMat[inputMat$Phase==.np &
                                              inputMat$Group==.ng,
                                              varNames]
                               randFxCovMat[[.np]][[.ng]] <- cor2cov(CorMat,
                                                               unlist(.V))
                             }
                           }
                           rm(p, g, .np, .ng, .V)

                           # populate uneditable objects
                           unStdRandFxMean <- "Implementation Pending"

                           # construct the fixed effects design matrix, only one
                           # is needed across all combinations of group and phase
                           # by using maxRandFx, any unneeded columns will be
                           # ignored when constructing data
                           designMat <- makeDesignMat(
                             phases     = phases              ,
                             phaseNames = names(phases)       ,
                             maxRandFx  = length(randFxOrder) ,
                             design     = 'polyICT'           )

                           # get the number of observations
                           nObs <- length(c(unlist(phases)))
                           n    <- sum(groups)

                           #
                           # populate private
                           #
                           #private$.edit              <- TRUE

                           # editable without a new call to $new
                           private$.inputMat          <- inputMat
                           private$.yMean             <- yMean
                           private$.ySD               <- ySD
                           private$.randFxVar         <- randFxVar
                           private$.randFxCorMat      <- randFxCorMat
                           private$.randFxCovMat      <- randFxCovMat
                           private$.error             <- error
                           private$.merror            <- merror

                           # not editable
                           private$.n                 <- n
                           private$.nObs              <- nObs
                           private$.groups            <- groups
                           private$.phases            <- phases
                           private$.phaseNames        <- names(phases)
                           private$.groupNames        <- names(groups)
                           private$.designMat         <- designMat
                           private$.propErrVar        <- propErrVar
                           private$.unStdRandFxMean   <- unStdRandFxMean
                           private$.randFxOrder       <- randFxOrder

                           # not implemented
                           private$.randFxFam         <- randFxFam
                           private$.randFxFamParms    <- randFxFamParms

                           # variances TODO repopulate these after moving their function to ??
                           #private$.variances         <- variances
                           #private$.expectedVariances <- expectedVariances
                           # internals
                           #private$.edit              <- FALSE


                         },

                         print = function(...)
                         {
                           # use super to call the print function of the parent class
                           super$print()

                           # TODO deprecate or generalize for list objects
                           ## add print options for the child class
                           #cat("\n\nEffect sizes:\n",
                           #    paste(unlist(lapply(self$randFxMean, names)), '=',
                           #          unlist(self$randFxMean), '\n'),
                           #    "\nRandom Effects\n",
                           #    "\nCorrelation matrix:\n", catMat(self$randFxCorMat),
                           #    "\nCovariance matrix:\n",  catMat(round(self$randFxCovMat,3))
                           #)

                         },

                         # update function to repeate QC steps in $new (which
                         # calls $initialize) rather than repeating this code
                         # in each active binding
                         update = function(...)
                         {
                           # Turn off warnings so that active binding messages,
                           # which should be implemented as warnings, are
                           # turned off (checkPolyICT will handle via errors)
                           options(warn=-1)
                           #self$edit <- TRUE

                           # This will call each active binding in self for
                           # passed parameters, hence warn=-1
                           dots <-  list(...)#match.call(expand.dots = FALSE)$...
                           #print(dots)
                           dotsNames <- names(dots)
                           for(i in seq_along(dots))
                           {
                             if( dotsNames[i] %in% names(self) )
                             {
                               self[[dotsNames[i]]] <- dots[[i]]
                             }
                             if( ! dotsNames[i] %in% names(self) )
                             {
                               message("The parameter `", dotsNames[i], "` is not ",
                                    "a valid parameter for a `polyICT`\n",
                                    "object and will be ignored.")
                             }
                           }
                           # only run this if
                           if(names(dots) %in% c('n', 'randFxMean', 'phases',
                                                 'randFxCorMat', 'randFxVar'))
                           {
                             polyInputs <- checkPolyICT(
                               n            = self$n             ,
                               randFxMean   = self$randFxMean    ,
                               phases       = self$phases        ,
                               randFxCorMat = self$randFxCorMat  ,
                               randFxVar    = self$randFxVar
                             )

                             self$n                <- polyInputs$n
                             self$randFxCorMat     <- polyInputs$randFxCorMat
                             self$randFxCovMat     <- polyInputs$randFxCovMat
                             self$randFxVar        <- polyInputs$randFxVar
                             self$phaseNames       <- polyInputs$phaseNames
                             self$groupNames       <- polyInputs$groupNames
                             self$maxRandFx        <- polyInputs$maxRandFx
                             self$unStdRandFxMean  <- polyInputs$unStdRandFxMean
                             rm(polyInputs)

                             if(!all(names(self$phases)==self$phaseNames))
                             {
                               names(self$phases) <- self$phaseNames
                             }

                             self$designMat <- makeDesignMat(self$phases,
                                                             self$phaseNames,
                                                             self$maxRandFx,
                                                             'polyICT')

                             self$nObs <- length(c(unlist(self$phases)))
                           }

                           # reset warnings
                           options(warn=0)
                           #self$edit <- FALSE

                           # return self to allow for chaining of method calls
                           invisible(self)
                         },

                         # TODO we don't want to make the user pass multiple
                         # randFx and errors, so we pass the parameters
                         makeData = function(seed=123, yMean=100, ySD=15)
                         {
                           seeds <- makeSeeds(seed, length(self$phaseNames) *
                                                length(self$groupNames))
                           seeds <- matrix(seeds, length(self$phaseNames),
                                           length(self$groupNames))
                           data <- list(); d <- 1
                           for(p in seq_along(self$phaseNames))
                           {
                             thisp <- self$phaseNames[[p]]
                             for(g in seq_along(self$groupNames))
                             {
                               thisg <- self$groupNames[[g]]
                               # Sigma should be CorMat, not CovMat, otherwhise
                               # the slope variance (and higher polynomial terms)
                               # get scaled twice
                               Sigma <- self$randFxCorMat[[thisp]][[thisg]]
                               mu    <- self$unStdRandFxMean[[thisp]][[thisg]]
                               n     <- self$n[[thisg]]
                               nObs  <- length(self$phases[[thisp]])
                               dM    <- self$designMat[self$designMat$phase==thisp,]
                               rFxVr <- self$randFxVar[[thisp]][[thisg]]

                               # calls to polyData() here
                               data[[d]] <- polyData(seed       = seeds[p,g]      ,
                                                     n          = n               ,
                                                     nObs       = nObs            ,
                                                     mu         = mu              ,
                                                     Sigma      = Sigma           ,
                                                     self       = self            ,
                                                     dM         = dM              ,
                                                     rFxVr      = rFxVr           ,
                                                     propErrVar = self$propErrVar ,
                                                     group      = thisg           )
                               d <- d + 1
                             }
                           }
                           data <- do.call(rbind, data)

                           # rescale the y variance if !is.null
                           if(is.null(yMean)) yMean <- mean(data$y)
                           if(is.null(ySD))     ySD <- sd(data$y)
                           # rescaling is done regardless of yMean and ySD just
                           # in case only one is non-null
                           data$y <- scale(data$y)*ySD + yMean

                           # the makeData method is terminal, self is not returned
                           # which means chaining is not possible past this point
                           return(data)

                         }

                       )
)


# TODO:need to generalize beyond slopes
#' expectedVar
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @keywords internal
#'
expectedVar <- function(randFxCovMat, designMat, variances,
                        randFxMean, nObs, n)
{
  # 'total' N
  N <- nObs * n

  # variance at each time point
  vyt <-  randFxCovMat[1,1]            +
    designMat$Time^2*randFxCovMat[2,2] +
    2*randFxCovMat[1,2]                +
    variances$errorVar

  # total variance due to random effects and error variance
  sigmaT <- (N-1)^-1 * ( (n - 1) * sum(vyt) )

  # rescale the fixed effect sizes in terms of the variance when time = 1
  whereIsTeq1 <- which(designMat$Time==1)
  sdYt1 <- sqrt( vyt[whereIsTeq1] )
  randFxMean$fixdFx$phase     <- randFxMean$fixdFx$phase     * sdYt1
  randFxMean$fixdFx$phaseTime <- randFxMean$fixdFx$phaseTime * sdYt1

  # mean at each time point
  mt <-  (randFxMean$randFx$intercept                         +
            randFxMean$randFx$slope     * designMat$Time      +
            randFxMean$fixdFx$phase     * designMat$phase     +
            randFxMean$fixdFx$phaseTime * designMat$phaseTime
  )

  # overall mean
  m = mean(mt)

  # total variance due to fixed effects stacked over time
  muT <- (N-1)^-1 * ( n * sum((mt-m)^2) )

  # overall variance
  vy     <- sigmaT + muT
  #  (N-1)^-1 * ( n * sum((mt-m)^2) + (n - 1) * sum(vyt) )


  return( list(randFxMean = randFxMean ,
               Variances   = vyt         ,
               Means       =  mt         ,
               TotalMean   =   m         ,
               TotalVar    =  vy         ) )
}

#' checkPolyICT
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @keywords internal
#'
# TODO: if anything in this function is useful for polyICT2, export to functions
# or make it part of designICT to pass by inheritance
checkPolyICT <- function(n, randFxMean, phases, randFxCorMat, randFxVar)
{
  # check conformity of the elements in `randFxMean`
  randFxMean <<- randFxMean
  effectSizeLengths <- lapply(randFxMean[[1]], length)
  if(!all(unlist(effectSizeLengths)==effectSizeLengths[[1]]))
  {
    stop('There are unequal numbers of groups within each phase in `randFxMean`.\n',
         paste(names(effectSizeLengths), 'has', unlist(effectSizeLengths), 'groups.\n'))
  }
  groupNames <- lapply(randFxMean, names)
  groupNamesEqual <- outer(groupNames, groupNames, Vectorize(all.equal))
  if(!all(groupNamesEqual))
  {
    stop('The group names in `randFxMean` are not the same for all phases.\n',
         paste(names(randFxMean), ':', groupNames, '.\n'))
  }
  groupNames <- groupNames[[1]]
  if(length(randFxMean) != length(phases))
  {
    stop('`randFxMeans` is length ', length(randFxMean),
         ' while `phases` is length ', length(phase), '.\n',
         'The two should be equal length, i.e., `randFxMeans` has one\n',
         'set of parameters for each phase in `phases`.')
  }
  phaseNames <- names(phases)
  if(!all(names(randFxMean)==phaseNames))
  {
    stop('The phase names in `randFxMean` are not the same as the \n',
         'phase names in `phases`.\n',
         paste(names(randFxMean), 'vs.', names(phases), '.\n'))
  }

  # check conformity of correlation matrices, must be per phase, per group
  if(is.list(randFxCorMat))
  {
    randFxCorMatLengths <- lapply(randFxCorMat, length)
    # if randFxCorMat only given for phases, assume equal across groups
    if(all(names(randFxCorMat) %in% phaseNames) & !any(randFxCorMatLengths > 1))
    {
      randFxCorMatL <- randFxCorMatPop(phaseNames, groupNames, randFxCorMat, 'p')
    }
    # if randFxCorMat only given for groups, assume equal across phases
    if(all(names(randFxCorMat) %in% groupNames) & !any(randFxCorMatLengths > 1))
    {
      randFxCorMatL <- randFxCorMatPop(phaseNames, groupNames, randFxCorMat, 'g')
    }
    # if randFxCorMat given for both phases and groups, check dimension conformity
    if(all(names(randFxCorMat) %in% phaseNames) & all(randFxCorMatLengths > 1))
    {
      if( randFxCorMatLengths[[1]] != effectSizeLengths[[1]] )
      {
        stop('The list of correlation matrices in `randFxCorMat` do not have the same\n',
             'number of groups and/or phases as in `randFxMean`. You can specify\n',
             'a list with just one correlation matrix per phase which will be\n',
             'applied to each group. Or you can specify one correlation matrix per\n',
             'group which will be applied to each phase. See the examples in ?polyICT.')
      }
    }
  }

  # if only one randFxCorMat is given, repeat it for all phases and groups
  if(!is.list(randFxCorMat))
  {
    randFxCorMatL <- randFxCorMatPop(phaseNames, groupNames, randFxCorMat, 'n')
  }

  # check conformity of random effects variances, must be per phase, per group
  if(is.list(randFxVar))
  {
    randFxVarLengths <- lapply(randFxVar, length)
    # if randFxVar only given for phases, assume equal across groups
    if(all(names(randFxVar) %in% phaseNames) & !any(randFxVarLengths > 1))
    {
      randFxVarL <- randFxVarPop(phaseNames, groupNames, randFxVar, 'p')
    }
    # if randFxVar only given for groups, assume equal across phases
    if(all(names(randFxVar) %in% groupNames) & !any(randFxVarLengths > 1))
    {
      randFxVarL <- randFxVarPop(phaseNames, groupNames, randFxVar, 'g')
    }
    # if randFxVar given for both phases and groups, check dimension conformity
    if(all(names(randFxVar) %in% phaseNames) & all(randFxVarLengths > 1))
    {
      if(randFxVarLengths[[1]] != effectSizeLengths[[1]] )
      {
        stop('The list of correlation matrices in `randFxVar` do not have the same\n',
             'number of groups and/or phases as in `randFxMean`. You can specify\n',
             'a list with just one correlation matrix per phase which will be\n',
             'applied to each group. Or you can specify one correlation matrix per\n',
             'group which will be applied to each phase. See the examples in ?polyICT.')
      }
    }
  }

  # if only one randFxVar is given, repeat it for all phases and groups
  if(!is.list(randFxVar))
  {
    randFxVarL <- randFxVarPop(phaseNames, groupNames, randFxVar, 'n')
  }

  # if only one n is given, repeat it for all groups
  if(!is.numeric(n) | !is.vector(n))
  {
    stop('`n` must be a numeric vector of length 1 (equal group sizes),\n',
         'or the same length as the number of groups.')
  }
  if(length(n) == 1)
  {
    n <- rep(n, length(groupNames))
  }
  if(length(n) > length(groupNames)) n <- n[1:length(groupNames)]
  names(n) <- groupNames


  # update randFxCorMat and randFxVar
  # TODO add error if for some reason randFxCorMatL or randFxVarL don't exist
  if(exists('randFxCorMatL')) randFxCorMat <- randFxCorMatL
  if(exists('randFxVarL'))    randFxVar <- randFxVarL

  # check conformity of `randFxCorMat` with `randFxMean`, get randFxCovMat, and
  # get unstandardized effect sizes
  randFxCovMatL <- list()
  unStdRandFxMeanL <- list()
  for(p in seq_along(phaseNames))
  {
    for(g in seq_along(groupNames))
    {
      # check by name instead of index for situations where the user doesn't
      # index consistently but still has consistent names
      tP <- phaseNames[p]
      tG <- groupNames[g]
      # are the random effect means in randFxMean the same dimension as
      # the corresponding randFxCorMat?
      if( length(randFxMean[[tP]][[tG]]) != dim(randFxCorMat[[tP]][[tG]])[1] )
      {
        stop('There are ', length(randFxMean[[tP]][[tG]]), ' random effect means\n',
             'for ', tP, ' and ', tG, ' in `randFxMean`, but the corresponding\n',
             'correlation matrix in `randFxCorMat` has dimension ', dim(randFxCorMat[[tP]][[tG]])[1],
             '.')
      }
      # are the dimensions of randFxCorMat consitent with the number of variances
      # in
      if( dim(randFxCorMat[[tP]][[tG]])[1] != length(randFxVar[[tP]][[tG]]) )
      {
        stop('The correlation matrix in `randFxCorMat` has dimension ',
             dim(randFxCorMat[[tP]][[tG]])[1], ' for ', tP, ' and ', tG,
             '\n but there are ', length(randFxVar[[tP]][[tG]]),
             ' correpsonding variances in `randFxVar`.')
      }

      # check that `randFxCorMat` is a correlation matrix
      checkCorMat(randFxCorMat[[tP]][[tG]])

      # check that resulting covariance matrix is legit
      randFxCovMatL[[tP]][[tG]] <- cor2cov(randFxCorMat[[tP]][[tG]], randFxVar[[tP]][[tG]])
      checkCorMat(randFxCovMatL[[tP]][[tG]], FALSE)

      # get unstandardized effects
      randFxSD <- sqrt(diag(randFxCovMatL[[tP]][[tG]]))
      unStdRandFxMeanL[[tP]][[tG]] <- randFxMean[[tP]][[tG]]*randFxSD

    }
  }

  # get the maximum number of random effects
  maxRandFx <- max( unlist( effectSizeLengths ) ) - 1


  return( list(n                = n                 ,
               phaseNames       = phaseNames        ,
               groupNames       = groupNames        ,
               randFxCorMat     = randFxCorMat      ,
               randFxCovMat     = randFxCovMatL     ,
               randFxVar        = randFxVar         ,
               maxRandFx        = maxRandFx         ,
               unStdRandFxMean  = unStdRandFxMeanL ) )
}

#' checkRandFxMean
#' @author Stephen Tueller \email{stueller@@rti.org}
#'
#' @keywords internal
#'
checkRandFxMeanPoly <- function(randFxMean)
{
  if(! var( unlist( lapply(randFxMean, length) ) ) == 0)
  {
    stop('All phases must have the same number of groups.')
  }

  if(! var(unlist( lapply(randFxMean, function(x) lapply(x, length)) ) ) == 0 )
  {
    stop('All combinations of phase and group must have the same number of\n',
         'random effects.')
  }
}




